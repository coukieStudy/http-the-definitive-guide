## 4.1 TCP Connection

HTTP 통신은 TCP/IP를 통해 이루어진다. TCP 커넥션 하에서는 클라이언트와 서버 사이에 주고 받는 메시지들이 손상되거나 순서가 바뀌지 않고 안전하게 전달된다. 
 
TCP는 IP패킷이라는 작은 조각을 통해 데이터를 전달한다. HTTP가 메시지를 전달하고자 할 경우, 현재 연결되어 있는 TCP 커넥션을 통해 메시지 데이터의 내용을 순차적으로 전달하는데, TCP 는 세그먼트라는 단위로 데이터
스트림을 나누고, 이를 IP패킷에 담아서 전송한다. IP패킷에 포함되어 있는 정보는 다음과 같다.
* IP 패킷 헤더: 발신지와 목적지의 IP주소, 크기, 기타 플래그
* TCP 세그먼트 헤더: TCP 포트 번호, TCP 제어 플래그, 데이터의 순서와 무결성을 검증하기 위한 숫자값
* TCP 데이터 조각: 데이터 스트림 덩어리

TCP 커넥션은
```
<발신지 IP주소, 발신지 포트, 수신지 IP주소, 수신지 포트>
```
 의 네 가지 값으로 구분된다. 네 값이 모두 동일한 두 커넥션은 존재할 수 없다. 
 
 다음 그림은 클라이언트와 서버가 HTTP 트랜잭션을 수행하기 위한 소켓 API의 사용 방법이다.
 
 ![image](https://user-images.githubusercontent.com/37106166/110629458-8690d800-81e7-11eb-9e5a-dedd6c73a3a7.png)

## 4.2 TCP 성능에 대한 고려

HTTP 트랜잭션을 지연 시키는 원인은 여러 가지가 있다.
* 클라이언트는 URI에서 웹서버의 IP주소와 포트 번호를 알아내야 한다. 만약 최근에 해당 호스트에 방문한 적이 없으면, DNS를 통해서 호스트 명을 IP로 변환해야 한다.
* 클라이언트는 TCP 커넥션 요청을 서버로 보내고 서버가 커넥션 허가 응답을 회신하기를 기다린다.
* 커넥션이 맺어진 이후에 요청이 전송되고, 서버로부터 해당 요청이 처리되는데 시간이 소요된다
* 서버의 응답이 클라이언트에 도착할 때까지도 시간이 걸린다.

다음부터 다룰 내용은 HTTP에 영향을 주는 TCP 관련 지연들이다.
![image](https://user-images.githubusercontent.com/37106166/110646254-12abfb00-81fa-11eb-9c1f-934697af2e40.png)

#### TCP 핸드셰이크 지연
TCP 커넥션이 HTTP 성능을 저해시킬 수 있다.
일반적인 TCP 커넥션 순서는
1. 클라이언트가 'SYN' 플래그를 가진 패킷을 전송
2. 서버가 그 커넥션을 받으면 커넥션 요청이 받아들여졌음을 의미하는 'SYN'과 'ACK' 플래그를 포함한 패킷 전송
3. 클라이언트는 커넥션이 잘 맺어졌음을 알리기 위해서 서버에게 확인응답 신호를 보낸다. 오늘날의 TCP 클라이언트는 확인응답 패킷과 데이터를 함께 전송할 수 있다.

크기가 작은 HTTP 트랜잭션의 경우 절반 이상의 시간이 TCP 연결에 소요되기도 한다.

#### 확인응답 지연

TCP 세그먼트는 순번과 무결성 체크섬을 가지는데, 세그먼트의 수신자는 세그먼트를 온전히 받으면 작은 확인응답 패킷을 송신자에게 반환한다.
만약 송신자가 특정 시간안에 확인응답 메시지를 받지 못하면 패킷이 파기되었거나 오류가 있는 것으로 판단하고 데이터를 다시 전송한다.
확인 응답은 그 크기가 작기 때문에 TCP는 같은 방향으로 송출되는 데이터 패킷에 확인응답을 편승시킨다. 확인응답이 편승되는 경우를 늘리기 위해서 많은 TCP 스택은
송출할 확인응답을 특정 시간동안 버퍼에 저장해 두고, 이를 편승시키기 위한 송출 데이터 패킷을 찾는다. 만약 일정 시간 안에 데이터 패킷을 찾지 못하면 확인 응답은 별도 패킷을 만들어 전송된다.

HTTP 에서는 요청과 응답 두 형식으로만 이루어지기 때문에 확인 응답이 송출 데이터 패킷에 편승할 기회가 적다. HTTP 에서는 확인응답 지연 알고리즘으로 인한 지연이 자주 발생한다.

#### TCP slow start

TCP의 데이터 전송 속도는 TCP 커넥션이 만들어진 지 얼마나 지났는지에 따라 달라질 수 있다. TCP 커넥션은 처음에는 커넥션의 최대 속도를 제한하고 데이터가 성공적으로 전송됨에 따라서 속도 제한을 높여나간다.
TCP 느린 시작은 한 번에 전송할 수 있는 패킷의 수를 제한한다. 패킷이 성공적으로 전달되는 시점에 송신자는 추가로 2개의 패킷을 더 전송할 수 있는 권한을 얻는다.
처음에 한개의 패킷만 전송하고 확인 응답을 받으면 2개의 패킷을 보낼 수 있으며, 각각에 대한 확인 응답을 받으면 4개의 패킷을 보낼 수 있게 되는 식이다.

이는 인터넷의 급작스러운 부하와 혼잡을 방지하는 데 쓰이지만, 새로운 TCP 커넥션에서는 지연의 원인이 되기도 한다.


#### 네이글 알고리즘과 TCP_NODELAY

TCP 스택은 애플리케이션이 어떠한 크기의 데이터도 전송할 수 있도록 스트림 인터페이스를 제공한다. 하지만 TCP의 각 세그먼트는 40바이트 상당의 플래그와 헤더를 포함하여 전송하기 때문에 TCP가 작은 크기의 데이터를 포함한 많은 수의 패킷을 전송한다면 네트워크의 성능은 크게 떨어지게 된다.
네이글 알고리즘은 네트워크 효율을 위해서 패킷을 전송하기 전에 많은 양의 TCP 데이터를 하나의 덩어리로 합친다. 만약 다른 모든 패킷이 확인응답을 받았을 때에는 최대 크기보다 작은 패킷의 전송을 허락한다.
하지만 다른 패킷들이 아직 전송중이면, 데이터는 버퍼에 저장되고 다른 패킷들이 확인응답을 받았거나 충분한 패킷이 쌓였을 때 데이터각 전송되게 된다.

크기가 작은 HTTP 메시지는 패킷을 채우지 못하기 때문에 앞으로 생길지, 생기지 않을 지 모르는 추가적인 데이터를 기다리며 지연될 것이다.
또한 확인응답 지연과 함께 쓰일 경우 성능이 급격히 낮아질 수 있다. 네이글 알고리즘은 확인 응답을 기다리고, 확인응답 지연은 송출 데이터를 기다리기 때문이다.
HTTP 스택에 TCP_NODELAY 파라미터를 설정하여 네이글 알고리즘을 비활성화하기도 하는데, 이 경우에는 작은 크기의 패킷이 너무 많이 생기지 않도록 조정해야 한다.

#### TIME_WAIT의 누적과 포트 고갈

TCP 커넥션의 종단에서 커넥션을 끊으면 종단에서는 커넥션의 IP주소와 포트 번호를 작은 제어 영역에 기록해 둔다. 이 정보는 같은 주소와 포트 번호를 사용하는 새로운 TCP 커넥션이 일정시간 생성되지 않게 하기 위한 것이다.
이는 이전 커넥션과 관련된 패킷이 그 커넥션과 같은 주소와 포트 번호를 가지는 새로운 커넥션에 삽입되는 문제를 방지하기 위함이다.

일반적인 상황에서는 종료 지연이 문제가 되지는 않지만 성능 시험을 하는 상황에서는 문제가 될 수 있다. 성능 측정 대상 서버는 클라이언트가 접속할 수 있는 IP주소의 개수를 제한하기 때문이다.
포트고갈 문제를 겪지 않더라도, 커넥션을 너무 많이 맺거나 대기 상태로 있는 제어 블록이 너무 많아지는 상황은 주의해야 한다.


## HTTP Connection 관리
HTTP는 클라이언트와 서버 사이에 프락시 서버나 캐시 서버등과 같은 중개 서버가 놓이는 것을 허락한다.
어떤 경우에는 두 개의 인접한 HTTP 어플리케이션이 맺고 있는 커넥션에만 적용될 옵션을 지정해야 될 때가 있는데, 이 때 사용되는 것이 HTTP의 Connection Header이다.
Connection 헤더에는 세 종류의 토큰이 전달될 수 있다.
* HTTP 헤더 필드 명: 이 커넥션에만 해당되는 헤더들
* 임시적인 토큰 값: 커넥션에 대한 비표준 옵션
* close: 커넥션이 작업이 완료되면 종료되어야 함을 의미한다.

![image](https://user-images.githubusercontent.com/37106166/110653856-f8295000-8200-11eb-9720-59ee6963e426.png)

커넥션 관리가 제대로 이루어지지 않으면 TCP 성능이 매우 안좋아질 수 있다. 3개의 이미지가 있는 웹페이저를 보여주기 위해서는 4개의 HTTP 트랜잭션이 필요하다 (HTML 1개, 첨부된 이미지 3개).
각 트랜잭션이 새로운 커넥션을 필요로 한다면 커넥션을 맺는데 발생하는 지연과 느린 시작 지연이 발생할 것이다.

## 병렬 커넥선
HTTP는 클라이언트가 여러 개의 커넥션을 맺음으로써 여러 개의 HTTP 트랜젝션을 병렬로 처리할 수 있게 한다. 
![image](https://user-images.githubusercontent.com/37106166/110654824-d4b2d500-8201-11eb-8511-2a9e4ed1ef15.png)
각 커넥션의 지연 시간을 겹치게 하면 총 지연 시간을 줄일 수 있고, 클라이언트의 인터넷 대역폭을 한 개의 커넥션이 다 써버리는 것이 아니라면, 나머지 객체를 내려받는 데에 남은 대역폭을 사용할 수 있다.

병렬 커넥션이 항상 더 빠른 것은 아니다. 클라이언트의 네트워크 대역폭이 좁을 때, 대부분 시간을 데이터 전송하는 데에만 쓸 것이다. 여러 객체를 병렬로 내려받는 경우,
이 제한된 대역폭 내에서 각 객체를 전송받는 것은 느리기 때문에 성능상의 장점은 거의 없어지고, 여러 커넥션을 생성하면서 생기는 부하 때문에 순차적으로 내려받는 것보다 더 오래걸릴 수도 있다.

모든 클라이언트가 많은 수의 병렬 커넥션을 맺게 되면 서버의 성능을 크게 떨어트리기 때문에 브라우저는 실제로 병렬 커넥션을 사용하긴 하지만 적은 수의 병렬 커넥션만을 허용한다.
병렬 커넥션이 항상 더 빠른 것은 아니지만, 화면에 여러 개의 객체가 동시에 보이면서 내려받고 있는 상황을 볼 수 있기 때문에 사용자는 더 빠르게 내려받고 있는 것처럼 느낄 수 있다.


