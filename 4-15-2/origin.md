# 15장 엔티티와 인코딩 - 2

## 15.6 전송 인코딩과 청크 인코딩

콘텐츠 인코딩: 단지 메세지의 엔터티 부분만 인코딩

- 콘텐츠 인코딩은 콘텐츠 포맷과 연관이 있다.
    - 텍스트 파일 → gzip
    - JPEG → gzip x

전송 인코딩: 동일하게 엔터티 부분에만 적용되는데, 메세지 자체의 구조를 바꾼다. (e.g. 청크 인코딩)

### 15.6.1 안전한 전송

전송 인코딩은 다른 프로토콜에서도 네트워크를 통한 '안전한 전송'을 위해 존재했다.

HTTP에서 문제를 일으키는 이유는 몇 가지 존재.

1. 알 수 없는 크기
    - HTTP는 데이터에 앞서 Contnt-Length 헤더를 요구하기 때문에, 몇몇 서버는 크기를 알기 전에 데이터를 먼저 보내고 종결 꼬리말을 포함시켜 전송 인코딩으로 보내려고 시도한다.
2. 보안
    - 전송 인코딩을 사용해 알아보지 못하도록 뒤섞는 경우가 있다.

    → SSL과 같은 유명한 전송 계층 보안 방식이 있기에 흔하지 않다.

### 15.6.2 Transfer-Encoding 헤더

1. Transfer-Encoding: 안전한 전송을 위해 어떤 인코딩이 메시지에 적용되었는지 수신자에게 알려줌.
2. TE: 요청 헤더에 어떤 전송 인코딩을 사용할 수 있는지 보냄으로 서버에게 알려준다.

```
# Request Message
GET /new_producs.html HTTP/1.1
Host: ...
User-Agent: ...
TE: trailers, chunked

# Response Message
HTTP/1.1 200 OK
Transfer-Encoding: chunked
Server: Apache/3.0
...
```

### 15.6.3 청크 인코딩

전송 인코딩의 한 종류로서 메시지를 일정 크기의 청크 여럿으로 쪼개고, 순차적으로 보냄.

→ 청크 인코딩을 이용하면 메세지를 보내기 전에 전체 크기를 알 필요가 없어진다. 한 청크의 크기만 보내면 된다.

**청크와 지속 커넥션**

Client와 서버 사이의 Connection이 지속적이지 않다면, Client는 자신이 읽고 있는 본문의 크기를 알 필요가 없다. Client는 단순히 Connection이 닫힐 때까지 본문으로 간주하고 읽을 것.

→ 지속 커넥션에서는 본문을 쓰기 전에 Content-length 헤더에 본문의 길이를 담아서 보내줘야 한다.

청크 인코딩은 여러 청크로 쪼개 보낼 수 있게 해주는데, 지속적으로 일부를 보내다가 끝날 때는 크기가 0인 청크를 보내서 본문이 끝났음을 알린다 → 이후 다음 응답을 위해 커넥션 유지

![Untitled](https://user-images.githubusercontent.com/26040955/116429110-896f8700-a880-11eb-8394-1880f1bd5d8c.png)

**청크 인코딩된 메시지의 트레일러**

Trailer 헤더: 본문의 콘텐츠가 먼저 생성되어야 한다는 이유로 메시지 시작 시점에서는 그 값을 알 수 없는 추가적인 헤더 필드를 담을 수 있다.

→ Transfer-encoding, Trailer, Content-Length를 제외한 어떤 HTTP 헤더도 트레일러로 보낼 수 있다.

**가능한 조건 (둘 중 하나라도 만족하면 가능)**

1. Client의 TE 헤더가 트레일러를 받아들일 수 있음을 나타내는 경우
2. 선택적 메타데이터인 경우

### 15.6.4 콘텐츠와 전송 인코딩의 조합

콘텐츠 인코딩과 전송 인코딩은 동시에 사용될 수 있다.

1. 송신자가 콘텐츠 인코딩을 해서 HTML 파일을 압축
2. 청크 데이터를 전송 인코딩으로 전송
3. 수신자에서는 청크 데이터를 모두 받아서 합치고, 콘텐츠 디코딩을 해서 HTML 파일을 얻어냄.

### **전송 인코딩의 규칙**

- 전송 인코딩의 집합은 반드시 chunked를 포함해야 함. (유일한 예외 Connection 종료)
- 청크 전송 인코딩이 사용되었다면, 메시지 본문에 적용된 마지막 전송 인코딩이 존재해야 합니다.
- 청크 전송 인코딩은 반드시 본문에 한번이상 적용되어야 합니다.
- 전송인코딩은 HTTP1.1에서 소개된 비교적 새로운 기능이며, 비 HTTP1.1 애플리케이션에 전송 인코딩된 메시지를 보내지 않도록 주의해야합니다.

## 15.7 시간에 따라 바뀌는 인스턴스

같은 URL은 시간에 따라 다른 버전의 객체를 가리킬 수 있다.

→ 이 때문에 클라이언트가 자신이 갖고 있는 리소스의 사본이 서버가 갖고 있는 것과 정확히 같은지 판단하고, 상황에 따라서 새롭게 요청할 수 있는 것이 필요 (범위 요청과 델타 인코딩)

//그림 15-8

## 15.8 검사기와 신선도

**조건부 요청**: 클라이언트가 사본을 캐시하고 있는데, 만료된 경우 서버에 다시 요청. 하지만, 동일한 데이터일 경우 클라이언트는 데이터를 그대로 가지고 있는다.

### 15.8.1 신선도

Client가 얼마나 오랫동안 콘텐츠를 캐싱하고 있어야 하는지에 대한 것.

- 'Expires' Header: 만료 날짜를 명시 (e.g. Expires: Sun Mar 18 23:59:59 GMT 2001)
- 'Cache-Control' Header: 문서의 최대 수명

더 디테일한 부분 → [https://github.com/coukieStudy/http-the-definitive-guide/blob/main/2-7-1/origin.md](https://github.com/coukieStudy/http-the-definitive-guide/blob/main/2-7-1/origin.md)

### 15.8.2 조건부 요청과 검사기

위에서도 말했듯이 Client단에서 캐싱된 사본이 서버에서도 바뀌지 않은 경우 굳이 Client에서 받을 필요가 없다. 

→ 이를 위해, 조건부 요청을 하게 되는데 header로 보낸 조건이 참일 때만 동작하도록 한다.

예를 들어, If-Modified-Since: (A 날짜) 인 경우, A날짜 이후에 변경되지 않았으면 304 Not Modified을 보내고 변경되었다면 데이터를 보내주는 방식.

If-Modified-Since: Last-modified 시각 이후로 변한 게 있다면 사본을 보내라

If-UnModified-Since: Last-modified 시각 이후로 변한게 없다면, 사본을 보내라.

If-Match: ETag 응답 헤더에 들어있었던 것과 엔터티 태그가 같다면, 사본을 보내라.

If-Non-Match: ETag 응답 헤더에 들어있었던 것과 엔터티 태그가 다르다면, 사본을 보내라.

### 검사기 종류

- 약한 검사기: 리소스의 인스턴스를 고유하게 식별하지 못하는 경우 (e.g. 객체의 바이트 단위 크기)

→ e.g. Last-modified: 정확도가 최대 1초이기 때문, 1초 안에 여러번 변경될 수도 있다.

- 강한 검사기: 언제나 고유하게 식별 (e.g. 콘텐츠에 대한 암호 체크섬)

→ e.g. ETag: 매 번경마다 구분되는 값을 넣어두기 때문

두드러진 변화에 사용할 경우 약한 검사기를 사용하고, 모든 변화에 대응하려면 강한 검사기를 사용하는 것이 좋다.

## 15.9 범위 요청

**범위 요청**: HTTP 클라이언트가 받다가 실패한 엔터티를 일부 혹은 범위로 요청함으로써 다운로드를 중단된 시점에서 재개할 수 있다.

- client 범위 요청 예시

```
GET /bigfile.html HTTP/1.1
Host: ...
Range: bytes=4000- //4000바이트 이후를 요청한 것.
```

- server 응답 예시 - 범위 요청이 가능하다는 것을 보여줌

```
HTTP/1.1 200 OK
Date: ...
Server: Apache/1.2.4
Accept-Ranges: bytes //byte단위로 범위 요청 가능
```

## 15.10 델타 인코딩

Client에서 캐시가 만료되어서 새로운 페이지를 Server로부터 받는 경우, 전체 페이지를 받는 것보다 변경된 부분만 받는다면 더 빠를 것.

→ 델타 인코딩이 이를 수행해준다

- A-IM(Accept-Instance-Manipulation): 받아들일 수 있는 인스턴스 조작의 종류를 가리키는 클라이언트 요청 헤더
- IM: 요청에 적용된 인스턴스 조작의 종류를 명시하는 서버의 응답 헤더

![Untitled 1](https://user-images.githubusercontent.com/26040955/116429132-8e343b00-a880-11eb-9653-b80f4bd91767.png)

### 인스턴스 조작 종류

- vcdiff: vcdiff 알고리즘을 이용한 델타  - 텍스트가 아니더라도 동작하고 diff -e 보다 더 작은 델타를 생성
- diffe: 유닉스 diff -e 명령을 이용한 델타 - 파일에 대한 줄 단위 비교를 수행
- gdiff: gdiff 알고리즘을 이용한 델타
- gzip: gzip 알고리즘을 이용한 압축

....

**델타 인코딩은 전송 시간을 줄일 수 있지만 구현하기가 까다로울 수 있다.**

→ 서버는 비교하기 위해, Client가 가지고 있던 이전 버전의 사본을 모두 가지고 있어야 한다. 이만큼의 디스크 양이 많아질 것.
