# 3장 HTTP 메시지

## 3.4 상태 코드

#### 3.4.1 100-199 정보성 상태 코드

정보성 상태 코드는 HTTP/1.1에서 도입되었다.

표 3-6

100 Continue 상태 코드는 약간 혼란스럽다. 100 Continue는 HTTP 클라이언트 애플리케이션이 서버에 엔터티 본문을 전송하기 전에 그 엔터티 본문을 서버가 받아들일 것인지 확인하려고 할 때, 그 확인 작업을 최적화하기 위한 의도로 도입된 것이다.



**클라이언트와 100 Continue**

클라이언트는 100 Continue응답을 받고 싶다면 값을 100 Continue로 하는 Expect 요청 헤더를 보낼 필요가 있다. 만약 클라이언트가 엔터티를 보내지 않으려 한다면, 엔터티를 보낼 것이라고 생각하게 만들어 서버를 혼란에 빠뜨릴 뿐이기 때문이다.(?!) 따라서 클라이언트도 서버도 적당히 알아서 잘 처리해야한다. Ex) time out



**서버와 100 Continue**

서버가 100 Continue 값이 담긴 Expect 헤더가 포함된 요청을 받는다면, 100 Continue 응답 혹은 에러 코드로 답해야한다. 서버는 절대로 100 Continue 응답을 받을 것을 의도하지 않은 클라이언트에게 100 Continue 상태 코드를 보내서는 안 된다.(그렇게 하면 어떻게 되지..?)

서버가 100 Continue 응답을 보내기 전에 엔티티의 일부(혹은 전체)를 수신하면, 서버는 100 Continue를 보낼 필요가 없다. 클라이언트가 이미 계속 전송하기로 결정하였기 때문이다.

서버가 100 Continue 응담을 받을 것을 의도한 요청을 받고 난 상태에서, 엔터티 본문을 읽기 전에 요청을 끝내기로 결정 했다면, 서버는 그냥 응답을 보내고 연결을 닫아서는 안 된다. 클라이언트가 응답을 받을 수 없게 되기 때문이다.(4장의 "TCP 끊기와 리셋 에러" 참고)



**프락시와 100 Continue**

프락시는 버전에 따라 100 Continue 응답을 의도한 요청을 처리해야한다. 다음 홉(next-hop) 서버(6장 참고)가 HTTP/1.1 이상 혹은 어떤 버전인지 모른다면, 요청을 전달하고 1.1미만의 버전이면  417 Expectation Failed 에러로 응답해야한다.

이를 위해 다음 홉 서버들에 대한 상태 등을 캐싱하면 프락시에 도움이 된다.



#### 3.4.2 200-299 성공 상태 코드

표3-7 



#### 3.4.3 300-399 리다이렉션 상태 코드

리다이렉션 상태 코드는 클라이언트가 관심있어 하는 리소스에 대해 다른 위치를 사용하라고 말해주거나 그 리소스의 내용 대신 다른 대안 응답을 제공한다. 302, 303, 307 상태 코드 사이에서 중복되는 부분이 있음을 눈치챘을 것이다. 이 상태 코드들이 어떻게 사용되는가에 대해서는 약간 미묘한 차이가 있는데, 이는 주로 HTTP/1.0과 HTTP/1.1 애플리케이션이 이 상태 코드를 다루는 방식의 차이점에 기인한다. HTTP/1.0 클라이언트가 POST 요청을 보내고 302 리다이 렉트 상태 코드가 담긴 응답을 받으면， 클라이언트는 Location 헤더에 들어있는 리다이렉트 URL을 GET 요청으로(원래 요청에서 POST였던 것과는 달리) 따라갈 것이다. HTTP/1.0 서버가 HTTP/1.0 클라이언트로부터 POST 요청을 받은 뒤 302 상태 코드를 보내는 상황이라면, 서버는 클라이언트가 리다이렉션 URL에 대한 GET 요청으로 리다이렉트를 따라가길 기대한다. 그런데 HTTP/1.1이 혼란을 일으켰다. HTTP/1.1 명세는 그러한 리다이렉션을 위해 303 상태 코드를 사용한다(서버는 뒤이어 GET 요청이 오도록 POST 요청을 리다이렉션하기 위해 303 상태 코드를 보낼 수 있다). 이 혼란을 막기 위해, HTTP/1.1 명세는 HTTP/1.1 클라이언트의 일시적인 리다이렉트를 위해 302 상태 코드 대신 307 상태 코드를 사용하라고 한다. 그리고 서버는 302 상태 코드를 HTTP/1.0 클라이언트에게 사용하기 위해 남겨둘 수 있을 것이다.

#### 3.4.4 400-499 클라이언트 에러 상태 코드

클라이언트가 서버에서 처리할 수 없는 요청 메세지를 보냈을 경우에 사용하는 코드다. (DNS에서도 404에러를 보낼 수 있나..?)

#### 3.4.5 500-599 서버 에러 상태 코드

서버 자체에서 발생하는 에러 코드다.

## 3.5 헤더

헤더는 크게 아래 다섯가지로 분류 가능

- **일반 헤더**

  클라이언트와 서버 모두 사용하는 헤더. Ex) Date: Tue, 3 oct 1974 02:16:00 GMT

- **요청 헤더**

  요청 메세지에서만 사용하는 헤더. Ex) Accept : */* (어떤 미디어 타입이든 받을 수 있다고 서버에 알려줌)

- **응답 헤더**

  응답 메세지에서만 사용하는 헤더. Ex) Server: Tiki-Hut/1.0 (클라이언트에게 서버의 종류와 버전을 알려줌)

- **엔터티 헤더**

  엔터티 본문에 대한 헤더. Ex) Content-Type : text/html; charset=iso-latin-1 (엔터티가 iso-latin-1 문자집합으로 된 HTML문서임을 알려줌)

- **확장 헤더**

  비표준 헤더.

#### 3.5.1 일반 헤더

표3-11

**일반 캐시 헤더**

표3-12

#### 3.5.2 요청 헤더

**Accept 관련 헤더**

**조건부 요청헤더**

**요청 보안 헤더**

**프락시 요청 헤더**

#### 3.5.3 응답 헤더

**응답 보안 헤더**

#### 3.5.4 엔터티 헤더

**콘텐츠 헤더**

**엔터티 캐싱 헤더**



